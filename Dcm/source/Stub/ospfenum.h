/* Copyright (c) 2005-2013 Brocade Communications Systems, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
$Log: /ospf/ospf_enums.h $
 * 
 * 2     10/22/96 5:11p Cindy
 * Release Version 1.50
 * 
 * 1     6/05/96 3:36p Cindy
 * First Beta Release
*/
/************************************************************************/
/*	Copyright (C) 1995 - 1996 Router Engines, Inc.								*/
/*	Unpublished - rights reserved under the Copyright Laws of the			*/
/*	United States.  Use, duplication, or disclosure by the 					*/
/*	Government is subject to restrictions as set forth in 					*/
/*	subparagraph (c)(1)(ii) of the Rights in Technical Data and 			*/
/*	Computer Software clause at 252.227-7013.										*/
/*	Router Engines, Inc., P.O. Box 3604 Newport Beach, CA 92659				*/
/************************************************************************/
#ifndef _OSPFENUM_H_
#define _OSPFENUM_H_

enum	OSPF_RETURN_FLAGS
{
	NO_PROBLEM = 0x0,
	NO_BUFFERS = 0x1,
	BAD_REQUEST = 0x2	
};

enum	OSPF_UNION_PACKET_TYPES
{
	OSPF_HELLO_PACKET	= 0x01,
	OSPF_DATABASE_DESCRIPTION_PACKET	= 0x02,
	OSPF_LINK_STATE_REQUEST_PACKET = 0x03,
	OSPF_LINK_STATE_UPDATE_PACKET = 0x04,
	OSPF_LINK_STATE_ACKNOWLEDGEMENT_PACKET = 0x05
};

enum	OSPF_PACKET_STATE
{
	GOOD_RECEIVE = 0x00,
	OSPF_ERROR_ACKNOWLEDGEMENT_BAD = 0x01,
	OSPF_ERROR_ACKNOWLEDGEMENT_DUPLICATE = 0x02,
	OSPF_ERROR_ACKNOWLEDGEMENT_STATE = 0x03,
	OSPF_ERROR_ACKNOWLEDGEMENT_TYPE = 0x04,
	OSPF_ERROR_DATABASE_DESCRIPTION_E_BIT = 0x05,
	OSPF_ERROR_DATABASE_DESCRIPTION_ROUTER_ID = 0x06,
	OSPF_ERROR_DATABASE_DESCRIPTION_STATE = 0x07,
	OSPF_ERROR_DATABASE_DESCRIPTION_TYPE = 0x08,
	OSPF_ERROR_HELLO_E_BIT = 0x09,
	OSPF_ERROR_HELLO_ID = 0x0a,
	OSPF_ERROR_HELLO_MASK = 0x0b,
	OSPF_ERROR_HELLO_ROUTER_DEAD_INTERVAL = 0x0c,
	OSPF_ERROR_HELLO_TIMER = 0x0d,
	OSPF_ERROR_HELLO_VIRTUAL = 0x0e,
	OSPF_ERROR_OSPF_AUTHENTICATION_KEY = 0x0f,
	OSPF_ERROR_OSPF_AUTHENTICATION_TYPE = 0x10,
	OSPF_ERROR_OSPF_INTERFACE_DOWN = 0x11,
	OSPF_ERROR_OSPF_PACKET_TYPE = 0x12,
	OSPF_ERROR_REQUEST_BOGUS = 0x13,
	OSPF_ERROR_REQUEST_EMPTY = 0x14,
	OSPF_ERROR_UPDATE_STATE = 0x15,
	STOP_PROCESSING_PACKET = 0x16,
	OSPF_ERROR_DATABASE_DESCRIPTION_MTU = 0x17,
	OSPF_SEQUENCE_NUMBER_MISMATCH = 0x18,
	OSPF_ERROR_HELLO_N_BIT = 0x19,
	OSPF_ERROR_CHECKSUM = 0x1a,
	OSPF_MAX_ERROR
};

enum	OSPF_NEIGHBOR_EVENT
{
	HELLO_RECEIVED = 0x0000,
	START = 0x01,
	TWO_WAY_RECEIVED = 0x02,
	NEGOTIATION_DONE = 0x03,
	EXCHANGE_DONE = 0x04,
	BAD_LINK_STATE_REQUEST = 0x05,
	LOADING_DONE = 0x06,
	ADJACENCY_OK = 0x07,
	SEQUENCE_NUMBER_MISMATCH = 0x08,
	ONE_WAY = 0x09,
	KILL_NEIGHBOR = 0x0a,
	INACTIVITY_TIMER = 0x0b,
	DOWN_INDICATION_FROM_LOWER_LEVEL_PROTOCOLS_RECEIVED = 0x0c,
	DATABASE_FILTER_OPTION_CHANGED = 0x0d
};

enum	OSPF_NEIGHBOR_MODE
{
	CLEAR_MODE = 0x00,
	SLAVE = 0x01,
	MASTER = 0x02,
	SLAVE_HOLD = 0x04		/* holding the last database summary delay */
};

enum	OSPF_NEIGHBOR_STATE
{
	NEIGHBOR_DOWN = 0x01,
	NEIGHBOR_ATTEMPT = 0x02,
	NEIGHBOR_INITIALIZING = 0x03,
	NEIGHBOR_2_WAY = 0x04,
	NEIGHBOR_EXCHANGE_START = 0x05,
	NEIGHBOR_EXCHANGE = 0x06,
	NEIGHBOR_LOADING = 0x07,
	NEIGHBOR_FULL = 0x08
};

enum	OSPF_INTERFACE_EVENT
{
	INTERFACE_UP = 0x00,
	WAIT_TIMER = 0x01,
	BACKUP_SEEN = 0x02,
	NEIGHBOR_CHANGE = 0x03,
	LOOP_INDICATION = 0x04,
	UNLOOP_INDICATION = 0x05,
	INTERFACE_DOWN = 0x06,
	INTERFACE_PASSIVE =0x07
};

enum	OSPF_INTERFACE_STATE
{
	INTERFACE_IS_DOWN	= 0x01,
	INTERFACE_LOOPBACK = 0x02,
	INTERFACE_WAITING = 0x03,
	INTERFACE_POINT_TO_POINT = 0x04,
	INTERFACE_DESIGNATED_ROUTER = 0x05,
	INTERFACE_BACKUP_DESIGNATED_ROUTER = 0x06,
	INTERFACE_DESIGNATED_ROUTER_OTHER = 0x07,
	INTERFACE_IS_PASSIVE =0x08
};

/* BRCD: Definition of BROADCAST is conflicting with FOS definition and hence undefined */
#ifdef BROADCAST
#undef 	BROADCAST
#endif
enum	OSPF_INTERFACE_TYPE
{
	INVALID_LINK_TYPE = 0x0,
	BROADCAST = 0x01,
	NBMA = 0x02,
	POINT_TO_POINT = 0x03,
	VIRTUAL_LINK = 0x04,
	POINT_TO_MULTIPOINT = 0x05,
	NON_BROADCAST = 0x06,
	SHAM_LINK = 0x07
};

enum	OSPF_SEQUENCE_STATE
{
	NORMAL = 0x00,
	WAITING_FOR_MAXIMUM_SEQUENCE_INSTANCE_TO_BE_FLUSHED = 0x01,
	DONE_FLUSHING_MAXIMUM_SEQUENCE_INSTANCE = 0x02
};

/* Link State Types */

enum GR_TLV_TYPE
{
	TLV_GRACE_PERIOD = 0x01,
	TLV_GRACE_RESTART_REASON = 0x02,
	TLV_INTERFACE_ADDRESS = 0x03
};

enum LS_TYPE
{
	LS_ROUTER = 0x1,
	LS_NETWORK = 0x2,
	LS_SUMMARY_NETWORK = 0x3,
	LS_SUMMARY_AS_BOUNDARY_ROUTER = 0x4,
	LS_AS_EXTERNAL = 0x5,
	LS_GROUP = 0x6,
	LS_AS_NSSA_EXTERNAL = 0x7,
	LS_NORMAL_MAX = LS_AS_NSSA_EXTERNAL,
	LS_TYPE_8 = 0x8,
	LS_OPAQUE_LINK = 0x9,
#ifdef MPLS	//OSPF_TE
	LS_OPAQUE_AREA = 0xA,
	LS_OPAQUE_AS = 0XB,
	LS_MAX = 0xC
#else //BRCD: MPLS	//OSPF_TE
	LS_MAX = 0xA
#endif //BRCD: MPLS	//OSPF_TE
};

#ifdef MPLS	//OSPF_TE
enum TE_TLV_TYPE
{
	TE_ROUTER_ADDRESS = 1,
	TE_LINK = 2
};
enum TE_LINK_TLV_TYPE
{
	LINK_TYPE = 1,
	LINK_ID	= 2,
	LOCAL_IP_ADDRESS = 3,
	REMOTE_IP_ADDRESS = 4,
	TE_METRIC = 5,
	MAX_BW = 6,
	MAX_RESERVABLE_BW = 7,
	UNRESERVED_BW = 8,
	ADMIN_GROUP	=9
};
#endif //BRCD: MPLS	//OSPF_TE

//nsr
enum	OSPF_LSA_SYNC_STATE
{
	TO_BE_SYNCED = 0x1,
	SYNCED_AND_ACKED = 0x02,
	TO_BE_DELETED_FROM_SYNC_LIST = 0x03,
	DELETED_FROM_SYNC_LIST = 0x4
};


enum	ROUTER_LINK_TYPE
{
	ROUTER_LINK_TYPE_ROUTER = 0x1,
	ROUTER_LINK_TYPE_TRANSIT_NETWORK = 0x2,
	ROUTER_LINK_TYPE_STUB_NETWORK = 0x3,
	ROUTER_LINK_TYPE_VIRTUAL = 0x4
};

enum	ACKNOWLEDGEMENT_RETURN_TYPE
{
	NO_ACKNOWLEDGEMENTS_LEFT = 0x00,
	ACKNOWLEDGEMENTS_LEFT = 0x01
};

enum ROUTING_TABLE_UPDATE_ACTION
{
	NO_ACTION = 0x00,
	REPLACE_PATH = 0x01,
	ADD_PATH = 0x02
};

enum	ROUTE_DESTINATION_TYPE
{
	DESTINATION_TYPE_NETWORK = 0x00,
	DESTINATION_TYPE_ASBR = 0x01,			/* autonomous system border router */
	DESTINATION_TYPE_ABR = 0x02,			/* area border router */
	DESTINATION_TYPE_VIRTUAL = 0x04,
	DESTINATION_TYPE_ASE = 0x08,			/* external to the autonomous system */
	DESTINATION_TYPE_WILDCARD = 0xFF
};

enum	ROUTE_PATH_TYPE
{
	ROUTE_PATH_TYPE_INTRA = 0x00,
	ROUTE_PATH_TYPE_INTER = 0x01,
	ROUTE_PATH_TYPE_1_EXTERNAL = 0x02,
	ROUTE_PATH_TYPE_2_EXTERNAL = 0x03,
	ROUTE_PATH_TYPE_EXTERNAL = 0x04,
	ROUTE_PATH_TYPE_SHAM_INTRA = 0x05,
	ROUTE_PATH_TYPE_SHAM_INTER = 0x06,
	ROUTE_PATH_TYPE_SHAM_1_EXTERNAL = 0x07,
	ROUTE_PATH_TYPE_SHAM_2_EXTERNAL = 0x08,
	ROUTE_PATH_TYPE_1_NSSA_EXTERNAL = 0x09,
	ROUTE_PATH_TYPE_2_NSSA_EXTERNAL = 0x0a,	
	ROUTE_PATH_TYPE_WILDCARD = 0xFF
};

enum COUNTER_ACTION_TYPE
{
	INCREMENT_COUNTERS = 0x0,
	DECREMENT_COUNTERS = 0x1
};

enum OSPF_PRINTF_GROUPS
{
	OSPF_INTERFACE_PRINTF = 0x0,
	OSPF_NEIGHBOR_PRINTF = 0x1,
	OSPF_MEMORY_PRINTF = 0x2,
	OSPF_ALARM_PRINTF = 0x3,
	OSPF_SNMP_PRINTF = 0x4,
	OSPF_PACKET_PRINTF = 0x5,
	OSPF_ROUTING_TABLE_PRINTF = 0x6,
	OSPF_DEBUG_PRINTF = 0x7
};

enum OSPF_ROUTING_TABLE_ENTRY_STATE
{
	OSPF_ROUTING_TABLE_ENTRY_VALID = 0x0,
	OSPF_ROUTING_TABLE_ENTRY_INVALID = 0x1,
	OSPF_ROUTING_TABLE_ENTRY_CHANGED = 0x2,
	OSPF_ROUTING_TABLE_ENTRY_NEW = 0x3,
	OSPF_ROUTING_TABLE_ENTRY_PATH_TYPE_CHANGED =0x04,
	OSPF_ROUTING_TABLE_ENTRY_PATH_COST_CHANGED =0x05
};

enum OSPF_ROUTE_IMPORT_ACTION
{
	OSPF_ROUTE_IMPORT_ACTION_DO_NOT_IMPORT = 0x0,
	OSPF_ROUTE_IMPORT_ACTION_IMPORT = 0x1
};

/* BRCD: Changed enum-> typedef enum OSPF_RESTART_STATE */
typedef enum OSPF_RESTART_STATE
{
	OSPF_RESTART_STATE_NORMAL = 0,			// nornal:  FALSE
	OSPF_RESTART_STATE_NEIGHBOR_CONNECT = 1,	// establishing none-VI neighbors
	OSPF_RESTART_STATE_NEIGHBOR_FULL = 2,	// short delay to timer, all none-VI neighbors done

	OSPF_RESTART_STATE_VI_SPF = 3,	// enable spf run for VIs.
	OSPF_RESTART_STATE_VI_NEIGHBOR_CONNECT = 4,	// establishing VI neighbors
	OSPF_RESTART_STATE_VI_NEIGHBOR_FULL = 5,	// short delay to timer, all VI neighbors done
	
	OSPF_RESTART_STATE_SPF_ORIGINATE_LSA = 6,	// originate router/network LSAs, run SPF, all other LSAs
	OSPF_RESTART_STATE_FLUSH_LSA = 7	// flush all grace LSAs
} OSPF_RESTART_STATE;

typedef enum OSPF_INTERFACE_MODE
{
	OSPF_INTERFACE_MODE_NONE = 0,
	OSPF_INTERFACE_MODE_PASSIVE = 1,
	OSPF_INTERFACE_MODE_ACTIVE = 2
}OSPF_INTERFACE_MODE;

#endif /* _OSPFENUM_H_ */
